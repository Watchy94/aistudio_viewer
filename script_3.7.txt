// ==UserScript==
// @name         Google AI Studio | Conversation/Chat MarkDown-Export/Download (HTML→Markdown improved)
// @namespace    http://violentmonkey.net/
// @version      3.7
// @description  Export AI Studio conversations to Markdown with better preservation of formatting (titles, bold, lists).
// @author       3.7, Modified by STR & ChatGPT. Initially Vibe-Coded by Piknockyou
// @license      MIT
// @match        https://aistudio.google.com/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=aistudio.google.com
// @grant        GM_addStyle
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    // CONFIGURATION
    let INCLUDE_AI_THINKING = false;

    const EXPORT_FILENAME_PREFIX = 'aistudio_chat_export_';
    const SCROLL_DELAY_MS = 80;
    const THOUGHT_EXPAND_DELAY_MS = 500;
    const MAX_SCROLL_RETRIES = 200;

    let collectedData = new Map();
    let exportButtonState = 'IDLE';
    let abortController;
    let exportButton, thinkingButton;

    // --- UTILS ---
    function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function getCurrentTimestamp() {
        const n = new Date();
        const pad = (v) => String(v).padStart(2, '0');
        return `${n.getFullYear()}${pad(n.getMonth() + 1)}${pad(n.getDate())}_${pad(n.getHours())}${pad(n.getMinutes())}`;
    }

    // Convertit un sous-arbre DOM en Markdown (strong, em, listes, code, titres, blockquotes, liens…)
    function elementToMarkdown(root) {
        if (!root) return '';

        function walk(node) {
            const type = node.nodeType;

            // Texte
            if (type === Node.TEXT_NODE) {
                return node.nodeValue.replace(/\s+/g, ' ');
            }

            if (type !== Node.ELEMENT_NODE) return '';

            const tag = node.tagName.toLowerCase();
            const children = Array.from(node.childNodes);
            const inner = () => children.map(walk).join('');

            switch (tag) {
                case 'br':
                    return '\n';

                case 'p': {
                    const text = inner().trim();
                    return text ? text + '\n\n' : '';
                }

                case 'strong':
                case 'b': {
                    const text = inner().trim();
                    return text ? `**${text}**` : '';
                }

                case 'em':
                case 'i': {
                    const text = inner().trim();
                    return text ? `*${text}*` : '';
                }

                case 'code': {
                    const parent = node.parentElement;
                    if (parent && parent.tagName.toLowerCase() === 'pre') {
                        return node.textContent;
                    }
                    const text = node.textContent.replace(/\s+/g, ' ').trim();
                    return text ? '`' + text + '`' : '';
                }

                case 'pre': {
                    const code = node.textContent.replace(/^\n+|\n+$/g, '');
                    return '```\n' + code + '\n```\n\n';
                }

                case 'ul': {
                    const items = [];
                    for (const li of children) {
                        if (li.tagName && li.tagName.toLowerCase() === 'li') {
                            const text = walk(li).trim();
                            if (text) items.push('- ' + text);
                        }
                    }
                    return items.length ? items.join('\n') + '\n\n' : '';
                }

                case 'ol': {
                    const items = [];
                    let i = 1;
                    for (const li of children) {
                        if (li.tagName && li.tagName.toLowerCase() === 'li') {
                            const text = walk(li).trim();
                            if (text) items.push(i + '. ' + text);
                            i++;
                        }
                    }
                    return items.length ? items.join('\n') + '\n\n' : '';
                }

                case 'li': {
                    return inner().trim();
                }

                case 'a': {
                    const href = node.getAttribute('href') || '';
                    const text = inner().trim() || href;
                    if (!href) return text;
                    return `[${text}](${href})`;
                }

                case 'h1':
                case 'h2':
                case 'h3':
                case 'h4':
                case 'h5':
                case 'h6': {
                    const level = parseInt(tag[1], 10) || 1;
                    const text = inner().trim();
                    if (!text) return '';
                    return '#'.repeat(level) + ' ' + text + '\n\n';
                }

                case 'blockquote': {
                    const text = inner();
                    const lines = text
                        .split(/\n+/)
                        .map(l => l.trim())
                        .filter(Boolean)
                        .map(l => '> ' + l);
                    return lines.length ? lines.join('\n') + '\n\n' : '';
                }

                default:
                    return inner();
            }
        }

        let md = '';
        for (const child of root.childNodes) {
            md += walk(child);
        }

        md = md.replace(/[ \t]+\n/g, '\n');  // espaces en fin de ligne
        md = md.replace(/\n{3,}/g, '\n\n');  // trop de sauts de ligne
        return md.trim();
    }

    // On ne s'appuie plus sur le "Raw mode" : on lit le HTML riche
    async function toggleRawMode() {
        return true;
    }

    async function expandThinkingSections(modelDiv) {
        let expanded = false;
        const expandButtons = modelDiv.querySelectorAll('button');
        for (const button of expandButtons) {
            const txt = (button.textContent || '').toLowerCase();
            const aria = button.getAttribute('aria-expanded');
            if (aria === 'false' && (txt.includes('thought') || txt.includes('thinking') || txt.includes('show more'))) {
                button.click();
                expanded = true;
            }
        }
        if (expanded) await delay(THOUGHT_EXPAND_DELAY_MS);
    }

    async function extractData() {
        let newlyFound = 0;
        const turns = document.querySelectorAll('ms-chat-turn');

        for (const turn of turns) {
            const turnKey = turn;
            if (!collectedData.has(turnKey)) newlyFound++;

            const info = collectedData.get(turnKey) || {
                type: 'unknown',
                user: null,
                thought: null,
                response: null
            };

            // USER TURN
            if (turn.querySelector('.chat-turn-container.user')) {
                info.type = 'user';
                const raw = turn.querySelector('ms-text-chunk .very-large-text-container');
                if (raw) {
                    info.user = elementToMarkdown(raw);
                } else {
                    const node = turn.querySelector('.turn-content ms-cmark-node');
                    if (node) info.user = elementToMarkdown(node);
                }
            }
            // MODEL TURN
            else if (turn.querySelector('.chat-turn-container.model')) {
                info.type = 'model';

                if (INCLUDE_AI_THINKING) await expandThinkingSections(turn);

                // 1. EXTRACT THOUGHT
                if (!info.thought && INCLUDE_AI_THINKING) {
                    const rawThought = turn.querySelector('ms-thought-chunk .very-large-text-container');
                    if (rawThought) {
                        info.thought = elementToMarkdown(rawThought);
                    } else {
                        const node = turn.querySelector('ms-thought-chunk .mat-expansion-panel-body');
                        if (node) info.thought = elementToMarkdown(node);
                    }
                }

                // 2. EXTRACT RESPONSE
                if (!info.response) {
                    const contentChunks = Array.from(
                        turn.querySelectorAll('.turn-content > ms-prompt-chunk')
                    );

                    const cleanTexts = contentChunks
                        .filter(chunk => !chunk.querySelector('ms-thought-chunk'))
                        .map(chunk => {
                            const raw = chunk.querySelector('ms-text-chunk .very-large-text-container');
                            if (raw) return elementToMarkdown(raw);
                            return elementToMarkdown(chunk);
                        })
                        .map(t => t.trim())
                        .filter(t => t && !t.startsWith('Model') && !t.startsWith('Thoughts'));

                    if (cleanTexts.length > 0) {
                        info.response = cleanTexts.join('\n\n');
                    }
                }
            }

            collectedData.set(turnKey, info);
        }

        return newlyFound > 0;
    }

    async function runExport(withThinking) {
        INCLUDE_AI_THINKING = withThinking;
        abortController = new AbortController();
        setBtnState('WORKING');

        try {
            let scroller = document.querySelector('ms-autoscroll-container');
            if (!scroller) {
                const firstTurn = document.querySelector('ms-chat-turn');
                if (firstTurn && firstTurn.parentElement) {
                    let p = firstTurn.parentElement;
                    while (p && p.scrollHeight <= p.clientHeight) {
                        p = p.parentElement;
                    }
                    scroller = p || document.documentElement;
                } else {
                    scroller = document.documentElement;
                }
            }

            // partir du haut
            scroller.scrollTo(0, 0);
            await delay(500);
            await toggleRawMode();

            let retries = 0;
            let lastTop = -1;
            collectedData.clear();

            while (retries < MAX_SCROLL_RETRIES) {
                if (abortController.signal.aborted) break;

                await extractData();

                if (scroller.scrollTop === lastTop) {
                    retries++;
                } else {
                    retries = 0;
                }
                lastTop = scroller.scrollTop;

                if (scroller.scrollTop + scroller.clientHeight + 5 >= scroller.scrollHeight) {
                    retries++;
                } else {
                    scroller.scrollTop = scroller.scrollTop + scroller.clientHeight;
                }

                await delay(SCROLL_DELAY_MS);
            }

            await extractData();
            download();
            setBtnState('SUCCESS');
        } catch (e) {
            console.error(e);
            setBtnState('ERROR');
        }
    }

    function download() {
        const sorted = Array.from(collectedData.values());
        if (!sorted.length) {
            alert('No data found');
            return;
        }

        let text = 'Google AI Studio Chat Records\n=========================================\n\n';

        sorted.forEach(item => {
            if (item.type === 'user' && item.user) {
                text += `--- User ---\n${item.user}\n\n`;
            }
            if (item.type === 'model') {
                if (item.thought) {
                    text += `<thinking>\n${item.thought}\n</thinking>\n\n`;
                }
                if (item.response) {
                    let cleanResp = item.response.replace(/^--- AI Response ---\n/, '');
                    text += `--- AI Response ---\n${cleanResp}\n\n`;
                }
            }
            text += '------------------------------\n\n';
        });

        const blob = new Blob([text], { type: 'text/markdown' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `${EXPORT_FILENAME_PREFIX}${getCurrentTimestamp()}.md`;
        a.click();
    }

    function setBtnState(state) {
        exportButtonState = state;
        if (!exportButton || !thinkingButton) return;

        if (state === 'WORKING') {
            exportButton.disabled = true;
            thinkingButton.disabled = true;
            document.body.style.cursor = 'wait';
        } else {
            exportButton.disabled = false;
            thinkingButton.disabled = false;
            document.body.style.cursor = 'default';
        }
    }

    // --- DOM UI CREATION (SVG buttons) ---
    function createUI() {
        const container = document.querySelector('ms-toolbar .toolbar-right');
        if (!container || document.getElementById('ai-export-group')) return;

        const group = document.createElement('div');
        group.id = 'ai-export-group';
        group.style.display = 'flex';
        group.style.gap = '4px';
        group.style.margin = '0 8px';
        group.style.alignItems = 'center';

        const makeBtn = (svgPath, title, color, onClick) => {
            const b = document.createElement('button');
            b.title = title;
            b.className = 'mat-mdc-tooltip-trigger ms-button-borderless ms-button-icon';
            b.style.color = color;
            b.style.opacity = '0.8';
            b.style.transition = 'opacity 0.2s';
            b.style.padding = '8px';

            b.onmouseover = () => b.style.opacity = '1';
            b.onmouseout = () => b.style.opacity = '0.8';
            b.onclick = onClick;

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 24 24');
            svg.setAttribute('height', '24');
            svg.setAttribute('width', '24');
            svg.setAttribute('fill', 'currentColor');

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', svgPath);

            svg.appendChild(path);
            b.appendChild(svg);
            return b;
        };

        // Icône téléchargement (Standard)
        const downloadPath = 'M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z';

        // Icône cerveau (Thinking) simple
        const brainPath = 'M12 2a5 5 0 0 0-4.9 4H7A3 3 0 0 0 4 9v3a4 4 0 0 0 3 3.87V18a3 3 0 0 0 3 3h1v-6H9a1 1 0 0 1 0-2h2V7h1a3 3 0 0 1 3 3v2h1a2 2 0 0 1 0 4h-1v5a3 3 0 0 0 3-3v-2.13A4 4 0 0 0 20 12V9a5 5 0 0 0-5-5h-1A5 5 0 0 0 12 2z';

        exportButton = makeBtn(downloadPath, 'Export Standard', '#e3e3e3', () => runExport(false));
        thinkingButton = makeBtn(brainPath, 'Export with Thinking', '#A8C7FA', () => runExport(true));

        group.appendChild(exportButton);
        group.appendChild(thinkingButton);

        const more = container.querySelector('button[iconname="more_vert"]');
        if (more) container.insertBefore(group, more);
        else container.appendChild(group);
    }

    const obs = new MutationObserver(() => createUI());
    obs.observe(document.body, { childList: true, subtree: true });
    createUI();
})();

